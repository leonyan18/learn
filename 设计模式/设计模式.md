### 设计原则

1. 找出应用之中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起
2. 针对接口编程，而不是针对实现编程
3. 多用组合，少用继承
4. 为了交互对象的松耦合而努力
5. 类应该对扩展开放，对修改关闭

### 策略模式

#### 定义

定义了算法族，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

#### 例子

把鸭子的flybehavior定义成一个接口同是也是鸭子类的属性，飞行的实现类实现该接口，并在鸭子的实体类 setflybehavior() 

如模型鸭 extends 鸭子 并setflybehavior(flyonwaybehavior)；当然如果他中途会飞了也可以set其他的flybehavior

### 观察者模式

#### 定义

定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖都会收到通知并自动更新

#### 例子

报刊与订阅者，报刊给每个订阅者发送报纸，也可以管理订阅者，而订阅者能订阅或者取消订阅

#### 补充

1. 主题用一个共同的接口来更新观察者

2. java有内置的观察者模式 注意点在推(push)和拉(pull)还有changed标志上但可能会造成一些问题 如通知次序问题 并不是面向接口编程

   代码如下

   ~~~java
   public interface Observer {
       void update(Observable o, Object arg);//观察者可已从arg里面获取数据或者从o里获取数据
   }
   
   public class Observable {
       private boolean changed = false;//用来表示数据是否变化
       private Vector<Observer> obs;
       public void notifyObservers() {//表示不传数据让观察者自己拉数据
           notifyObservers(null);
       }
       public void notifyObservers(Object arg) {//arg!=null表示传数据给观察者
           Object[] arrLocal;
           synchronized (this) {
               if (!changed)
                   return;
               arrLocal = obs.toArray();
               clearChanged();
           }
           for (int i = arrLocal.length-1; i>=0; i--)
               ((Observer)arrLocal[i]).update(this, arg);
       }
       protected synchronized void setChanged() {
           changed = true;
       }
       protected synchronized void clearChanged() {
           changed = false;
       }
       public synchronized boolean hasChanged() {
           return changed;
       }
       //其他方法
   }
   ~~~

3. 有多个观察者时，不可以依赖特定的通知次序

### 装饰者模式

#### 定义

动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案